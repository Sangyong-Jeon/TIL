# 12월 13일

### 🚀 학습한 것

- 스프링 핵심 원리 - 기본편 강의
  - 스프링이란?
- 계층형 아키텍처
  - 계층형 아키텍처 문제점
- 네트워크 기초
  - 처리량과 지연 시간
  - 네트워크 토폴로지와 병목 현상
  - 네트워크 분류
  - 네트워크 프로토콜 표준화

### 🚀 나의 생각

스프링 부트로 JPA, QueryDSL, Spring Data JPA, Spring Security 등 학습하다보니 객체 지향적인 설계와 스프링의 핵심 원리에 대한 정보가 부족하다는걸 느꼈다.

MSA와 같이 다양한 서버 및 패키지 구조와 배포 환경을 생각하다 보니 아키텍처 구조에 대한 궁금증이 생겨 이것도 학습하기로 했다.

여러 구조와 배포 환경을 또 찾다보니 예전에 학습했던 네트워크가 애매해서 다시 복습하기로 했다.

- '만들면서 배우는 클린 아키텍처'라는 도서로 아키텍처 학습
- '면접을 위한 CS 전공지식노트'로 CS 지식 학습
- '스프링 핵심 원리 - 기본편' 강의로 스프링 핵심원리들을 실무에서 사용하는 것들로 학습

이 때 스프링 핵심 원리는 '토비의 스프링3.1'이라는 도서에 자세히 나오지만 지금의 나는 천천히 책을 읽기보단 실무에서 사용하는 스프링 핵심원리들을 알짜배기로 학습하고 싶기에 강의를 선택했다.

<br>

---

# 12월 14일

### 🚀 학습한 것

- TCP/IP 4계층 모델
  - 계층 구조
  - 전송 계층의 TCP와 UDP
    - 가상회선 패킷 교환 방식
    - 데이터그램 패킷 교환 방식
    - TCP 연결 성립 과정 (3-way handshake)
    - TCP 연결 해제 과정 (4-way handshake)
  - 링크 계층의 유선 LAN, 무선 LAN
    - 전이중화 통신(Full Duplex)
    - 반이중화 통신(Half Duplex)
  - 계층 간 데이터 송수신 과정
    - 캡슐화 과정
    - 비캡슐화 과정
  - PDU
- 계층형 아키텍처
  - 문제점
- 스프링 핵심 원리 - 기본편 강의
  - 좋은 객체 지향 프로그래밍이란?

### 🚀 나의 생각

HTTP 통신으로 시작되는 웹 개발을 먼저 사용해보고 네트워크에 대해 다시끔 학습하니 많이 와닿는다. 학습 후 실습이라는 말처럼 반대로 실습 후 학습을 하니 상상이 되면서 이해하기 쉬워진다.

<br>

이번에 TCP/IP에 대해 학습하면서 생각났던건데 최근 토스에서 3세대 웹표준 프로토콜인 HTTP/3를 도입했다고 봤었다. 이는 PG 업계 최초라고 한다. 내가 예전에 학습을 했을 때는 HTTP/3는 TCP 대신에 UDP를 사용하고 HTTP/1.1의 성능 개선에 초점이 맞춰졌다고 알고 있다. 이 때 나오는 TCP와 UDP의 개념과 네트워크 흐름, 계층을 학습하니 첫 HTTP를 학습했을 때와는 다르게 재미있다. 예전 같았으면 이런 IT 뉴스들은 바로 넘겼을 것 같은데 지금은 재밌어서 보게된다.

<br>

IT 업계에서 나오는 소식들은 이처럼 다양한 지식을 알고 있어야 빠르게 이해하고 트렌드를 파악할 수 있는 것 같다. IT 업계에서 트렌드를 맞춰서 못따라간다면 기술부채로 계속 쌓이면서 후에는 더 크게 힘들어지니까 말이다.

<br>

---

# 12월 15일

### 🚀 학습한 것

- 네트워크 기기
  - 네트워크 기기의 처리 범위 (계층별)
  - 애플리케이션 계층을 처리하는 기기
    - L7 스위치
    - L7 스위치와 L4 스위치 차이
    - 헬스 체크
    - 로드밸런서
  - 인터넷 계층을 처리하는 기기
    - 라우터
    - L3 스위치
  - 데이터 링크 계층을 처리하는 기기
    - L2 스위치
    - 브리지
  - 물리 계층을 처리하는 기기
    - NIC
    - 리피터
    - AP
- 계층형 아키텍처
- 스프링 핵심 원리 - 기본편 강의
  - 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

### 🚀 나의 생각

NGINX를 학습할 때 로드밸런서 역할과 리버스 프록시를 사용할 수 있다고 했다. 이 때 NGINX는 애플리케이션 계층에 속하므로 로드 밸런싱을 한다면 L7 스위치라고 볼 수 있다.

<br>

---

# 12월 16일

### 🚀 학습한 것

- IP 주소
  - ARP
  - 홉바이홉 통신
    - 라우팅 테이블
    - 게이트웨이
  - IP 주소 체계
    - IPv4와 IPv6
    - 클래스 기반 할당 방식
    - DHCP
    - NAT
- 스프링 핵심 원리 - 기본편 강의
  - 객체 지향 설계와 스프링
    - DI(Dependency Injection)
    - IoC(Inversion of Control)
    - IoC 컨테이너 / DI 컨테이너

### 🚀 나의 생각

컴퓨터 간의 통신은 IP 주소를 기반으로 하는데 이 때 ARP를 통해 MAC 주소를 찾아서 통신한다는 것을 알게 되었습니다. 또한 IP 주소를 통해 통신하는 과정을 홉바이홉(hop by hop) 통신이라 하는데 이 과정에서 각각의 라우터에 있는 라우팅 테이블의 IP를 기반으로 패킷을 전달한다는 것도 알게 되었습니다.

늘어나는 사물 인터넷에 비해 IP 주소의 한계가 올 텐데 어떻게 이 많은 사물로 인터넷을 쓰는가? 라는 궁금증이 있었는데 DHCP와 NAT를 통해 해결되었습니다.

컴퓨터를 켜면 IP를 자동으로 할당받는것이 DHCP이고, 패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 IP 주소 정보를 수정하는 방법이 NAT입니다. IPv4 주소만으로는 모든 주소를 감당하지 못하기에 공인 IP와 사설 IP를 나눠서 처리합니다. 공유기 1대는 인터넷과 직접 접속하는 공인 IP를 1개 두고 공유기를 이용하는 컴퓨터들은 각각 다른 사설 IP를 두고 사용하게 됩니다. 이 때 사용자가 많을 수록 공인 IP는 1개이기에 속도도 느려지게 됩니다.

이번 학습을 통해 공유기를 많이 사용하면 왜 느려지는지에 대한 대답이 되었습니다. 또한 NAT를 활용하는 방식이 포워드 프록시(Forward Proxy) 방식과 유사하다고 생각되었습니다. 따라서 NAT를 이용하게되면 누가 요청하는지 모르기에 어느정도 보안이 되는것 같습니다.

<br>

---

# 12월 17일

### 🚀 학습한 것

- 계층형 아키텍처의 대안
  - 단일 책임 원칙
  - 부수효과
  - 의존성 역전 원칙

### 🚀 나의 생각

올바르게 구축하고 몇 가지 추가적인 규칙을 정용하면 계층형 아키텍처는 유지보수가 쉬워지고 코드를 쉽게 변경 및 추가할 수 있다. 하지만 많은 것들이 잘못된 방향으로 흘러가도록 용인하기에 어렵다. 따라서 시간이 지날수록 품질 저하, 유지보수하기 어려워진다. 그렇다면 어떤 방법을 사용해야할까?

단일 책임 원칙은 "오로지 한 가지 일만 하는 것"이라고 직관적인 해석을 할 수 있지만 실제로는 "컴포넌트를 변경하는 이유는 오직 하나뿐이어야한다"라고 볼 수 있다. 즉, 변경할 이유가 한 가지라면 컴포넌트는 한 가지 일만 하게 된다.

- 컴포넌트를 변경할 이유가 한가지라면?
  - 어떤 다른 이유로 소프트웨어를 변경하더라도 신경쓸 필요 X
  - 소프트웨어가 변경되더라도 여전히 기대한대로 동작하므로

하지만 변경할 이유는 의존성을 통해 너무 쉽게 전파된다는 단점이 있다. A가 B,C,D를 의존한다면 A는 모든 컴포넌트를 의존하기에 다른 컴포넌트가 변경되면 같이 변경될 가능성이 매우 크다. 이런 예시처럼 변경할 이유가 쌓일수록 한 컴포넌트를 변경하는 것이 다른 컴포넌트가 실패하는 원인으로 작용할 수 있게 된다. 그래서 의존성을 낮추기 위해 의존성 역전 원칙(DIP)를 사용하는 것이다.

의존성 역전 원칙은 "코드상의 어떤 의존성이든 그 방향을 역전시킬 수 있다"이다. 도메인 계층이 영속성 계층을 의존하고 있으면 이 원칙을 사용해서 영속성 코드에 있는 의존성으로부터 도메인 로직을 해방시킬 수 있다. 이 방법이 클린 아키텍처와 육각형 아키텍처 스타일의 핵심 기능이라고 하는데 다음에는 이것을 학습해볼 것이다.

<br>

---

# 12월 19일

### 🚀 학습한 것

- HTTP
  - HTTP/1.0
  - HTTP/1.1
  - HTTP/2
  - HTTPS
  - HTTP/3

### 🚀 나의 생각

HTTP는 애플리케이션 계층에서 웹 서비스 통신에 사용이 되는 웹 통신 프로토콜이다. HTTP를 의식하지 않았더라도 기본적으로 사용하는 이 프로토콜은 웹 개발에서 중요한 위치에 있다. 흔히 요청과 응답에서 사용하는 프로토콜이므로 이 HTTP의 성능이 좋아질수록 웹의 성능도 좋아진다. 이런 HTTP를 학습하니 웹 개발에 있어서 도움이 많이 된 것 같다.

HTTP 1.0 부터 HTTP 2까지는 TCP를 기반으로 사용했지만 최근 토스에서 도입했던 HTTP 3은 UDP를 기반으로 한다. 더 정확하게는 UDP 기반의 프로토콜인 QUIC를 사용하여 통신하는 프로토콜이다. 학습하고 나니 다음과 같은 생각이 들었다.

- 왜 TCP에서 UDP로 갈아탔을까?
- HTTP/1 에서 HTTP/2가 나오는 시간만해도 15년 정도 걸렸는데 거기서 4년만에 HTTP/3이 나와?
- 현재도 HTTP/1 쓰는 곳도 있고 HTTP/2 점유율이 40% 정도인데..?

나는 HTTP에 대해 먼저 학습하지 않고 서버 개발을 학습했기에 지금껏 스프링을 HTTP/1.1으로만 사용했다. HTTP/2 버전으로 적용도 못해봤는데 이렇게 빠르게 HTTP/3가 메이저 배포가 됐을 줄은 몰랐다.

일단 저 질문에 대한 대답부터 하자면 TCP의 한계 때문에 UDP로 갈아타서 성능을 개선했다고 볼 수 있다. TCP와 UDP의 중요한 차이점이 신뢰도와 전송 속도인데 둘 다 정반대이다. TCP는 신뢰도를 위한 여러 검증과 방법을 사용하는데 이는 기본 기능 외에도 다른 부분들을 커스터마이징해야하는데 아무래도 제한 사항이 많아서 이런 제한 사항을 극복하기위해 UDP 기반인 QUIC 프로토콜을 사용하는 것 같다. 거기다가 TCP를 사용한 HTTP/2에서도 TCP HOLB 문제가 있기도 하니 이를 해결하기 위함도 있다.

정리해보면

- 초기 연결 설정 시 지연 시간 감소
  - QUIC는 TCP를 사용하지 않기에 3-웨이 핸드셰이크 과정 X
  - TCP+TLS를 이용한 HTTPS는 3 RTT가 필요
  - QUIC를 이용한 HTTPS는 1 RTT가 필요하므로 연결 설정에 소요되는 시간이 매우 줄음
- HTTP 레벨의 HOLB와 TCP 레벨에서의 HOLB 문제 해결
  - 독립 스트림을 통한 향상된 멀티플렉싱 기능 지원으로 해결
- TCP를 커스터마이징 하려면 여러 제한 조건들이 많고, UDP는 커스터마이징하기 용이함
  - UDP는 많은 옵션을 추가할 수 있음

이런 특징을 가졌기에 데이터 전송이 매우 중요한 서비스라면 HTTP/3 도입을 토스처럼 검토해보는게 좋을 것 같지만 그 외의 서비스라면 HTTP/2 버전부터 도입을 하는것이 나아보인다. 이런 통신 설정에 들어가는 비용도 만만치 않아보이기에 안해도 기술부채이고 해도 오버 엔지니어링인지 아닌지, 개발일정에 차질이 생기지 않을지, 개발 여력이 있을지 등 여러 가지를 생각해야하기 때문이다.

<br>

---

# 12월 21일

### 🚀 학습한 것

- 데이터베이스
- 클린 아키텍처
- 육각형 아키텍처

### 🚀 나의 생각

아키텍처 부분은 읽을수록 모르는 것 투성이라 진도가 너무 느리다. 그래도 이런 설계 부분에서 이런 생각을 가지면서 한다는게 신기하고 재미있다. 지금까지 읽은 것을 한 번 정리해본다.

계층형 아키텍처는 문제점이 있다.

- 데이터베이스 주도 설계를 유도함
  - 이는 비즈니스 관점에서는 맞지 않는 방법
  - 주 원인은 ORM 프레임워크
  - 도메인 로직을 먼저 생각해야함
  - 계층형 아키텍처의 토대는 데이터베이스이기 때문
- 도메인 계층에서 엔티티를 사용하는 것은 영속성 계층과 강한 결합을 유발
  - 강한 결합성이 생기면 변경에 용이하지 않음
- 여러 컴포넌트(유틸리티, 헬퍼 등)들을 영속성에 추가하여 쉽게 개발
  - 하위 계층이 상위 계층에 접근하기 위해서 컴포넌트를 계층 아래로 내림
  - 이는 결국 영속성 계층이 비대해짐
- 계층을 건너뛰는 구현하는 문제
  - 간단한 DB 저장이어서 도메인 계층을 건너뛰어서 바로 영속성 계층에 접근
- 테스트 하기 어려움
  - 계층을 건너뛰는 구현이 많아지면서 핵심 도메인 로직들이 퍼져나감
  - 따라서 단위 테스트 복잡도 상승
  - 다양한 영속성 컴포넌트에 의존성이 많이 쌓이면서 복잡도 상승
- 유스케이스 숨기기
  - 유스케이스가 간단해서 하나의 서비스가 여러개의 유스케이스를 담당하게 됨
  - 넓은 서비스는 영속성 계층에 많은 의존성
- 동시 작업의 어려움
  - 인터페이스를 먼저 정의한다면 실제 구현을 기다릴 필요없이 동시 작업이 가능함
    - 하지만 이는 데이터베이스 주도 설계를 하지 않는 경우만 가능
  - 넓은 서비스가 있다면 동시 작업하기 힘듬
    - 병합 충돌과 잠재적인 이전 코드로 되돌려야 하는 문제 야기

간단하게 적으려고 했지만 결국 많이 적게 되었다. 계층형 아키텍처는 잘 구축하면 좋지만 많은 것들이 잘못된 방향으로 흘러가게 용인하는 부분들이 많기에 엄격하게 개발하지 않는 이상 시간이 지날수록 품질 저하와 유지보수하기가 어려워진다. 따라서 이에 대한 대안으로는 다음과 같다.

- 단일 책임 원칙(SRP)
  - 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 함
  - 하지만 컴포넌트 간의 의존성을 통해 변경할 이유가 생겨나는 문제 발생
- 의존성 역전 원칙(DIP)
  - 의존성을 역전시켜서 컴포넌트가 변경할 이유를 줄임

위의 두가지 원칙이 가장 핵심이고 이것이 클린 아키텍처와 육각형 아키텍처의 핵심 기능이다. 클린 아키텍처와 육각형 아키텍처는 개념만 학습을 했지만 제대로 이해하지 못했기에 내일 다시 읽어봐야겠다.

이렇게 앞 부분만 아키텍처에 대한 개념을 학습했지만 많은 것들을 배웠다. 제대로 된 설계를 하지 않고 코드부터 구현하는 것은 결국 유지보수와 품질저하로 이어지고 이는 당장 눈에 보이는 것들이 아니다. 이런 아키텍처 시각을 넓히는 것도 좋은 소프트웨어 개발자가 되는 길이라고 생각된다. 시야가 넓어진다는 것이 이런 느낌일까? 아직도 많이 부족하지만 나의 궁금증으로 인해 여러가지를 학습할수록 시야가 넓어진다. 프레임워크 개발 학습이 아닌 아키텍처 설계나 CS지식 등을 학습하다보면 다른 분들이 조언해주신 부분들이나 왜 이런식으로 개발을 했는지 가끔 깨닫게 되는 것 같다.

2일전에 HTTP를 학습했었는데 뭔가 더 궁금해서 도서관에서 책 2권을 무심코 빌려버렸다... 나 어떡하지?

<br>

---

# 12월 22일

### 🚀 학습한 것

- 데이터베이스
  - ERD
  - 정규화 과정
    - 갱신 이상
    - 제1정규형
    - 제2정규형
    - 제3정규형
    - 보이스/코드 정규형 (BCNF)
- 스프링 핵심 원리 - 기본편 강의

### 🚀 나의 생각

예전에도 배웠던 것이지만 면접도 준비할겸 다시 보고있는 데이터베이스이다. 이번에는 설계에서 자주 그리는 ERD를 잠깐 살펴보고 정규화 과정을 복습하였다. 그 후 클린 아키텍처와 육각형 아키텍처를 다시 보았는데 경험해보지 못해서인지 아직도 와닿지가 않는다. 지금껏 학습했던 것들은 대부분 경험했거나 복습하는 것이어서 많이 와닿았지만 아키텍처 같은 새로운 관점으로 보는 것은 이를 토대로 무언가 만들어봐야 제대로 이해할 수 있을 것 같다. 다행히도 내가 읽는 책에는 코드로 직접 작성하여 경험해보는 실습부분도 있어서 다행이다.

아키텍처 책을 읽으면서 느꼈는데 유지보수가 쉽고 좋은 소프트웨어를 개발할 때 중요한 것은

- 의존성을 역전시켜 강한 결합을 없애거나 도메인 코드가 바깥쪽 코드에 의존하지 않게 하는 것
- 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결합을 제거하는 것
- 컴포넌트를 변경할 이유의 수를 줄이는 것 (변경할 이유는 한 가지로)

위 세가지가 중요하다고 느꼈는데 이는 개인적으로 DDD(도메인주도개발)에 가까운 원칙인 것 같다. 이런 내가 미래에 동료들과 협업하여 개발하는 모습을 상상하니 기분이 좋다.

그러고보니 학교 도서관 이용이 1월 10일까지어서 큰일났다. 아직 읽고싶은 책이 너무나 많은데 앞으로는 시간 배분을 잘해서 학습해봐야겠다.

<br>

---

# 12월 23일

### 🚀 학습한 것

- 데이터베이스
  - 트랜잭션
- 웹 성능 최적화

### 🚀 나의 생각

[개발자가 생각해야하는 웹 성능 최적화](https://ssdragon.tistory.com/131)라는 게시글을 작성했다. 여기서도 적었지만 웹 성능 최적화 기법이라는 책을 읽으면서 웹을 개발할 때는 이러한 부분도 고려해야 한다는 것을 깨달았다. 내가 개발하는 것은 결국 사용자에게 하나의 서비스를 하는 것인데 이런 운영 측면과 비즈니스적인 시각을 다시끔 생각해보게 되었다.
